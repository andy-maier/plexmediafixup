"""
Fixup that walks through the movie and episode items of the configured library
sections, and syncs the "title" field of each item by setting it to the title
tag found in the media file.
"""

from __future__ import print_function, absolute_import
import os
import sys
import locale
import re
import json
import six
import ffmpy
import subprocess
import plexapi
import plexapi.exceptions
import plexapi.utils
from plexmediafixup.fixup import Fixup
from plexmediafixup.utils.unicode import ensure_bytes, ensure_unicode


FIXUP_NAME = os.path.splitext(os.path.basename(__file__))[0]

# Encoding that will be used for ffmpeg fix script file
# Ideally, we want the encoding of sys.stdout, but when redirecting this
# returns None, so we fall back to the locale preferred encoding.
FIX_SCRIPT_ENCODING = sys.stdout.encoding or locale.getpreferredencoding(True)


class SyncTitle(Fixup):

    def __init__(self):
        super(SyncTitle, self).__init__(FIXUP_NAME)

    def run(self, plex, dryrun, verbose, path_mappings,
            section_types=None, section_pattern=None,
            ffmpeg_fix_script=None):
        """
        Standard parameters:

          plex (plexapi.PlexServer): PMS to work against.

          dryrun (bool): Dryrun flag.

          verbose (bool): Verbose flag.

          path_mappings (list(dict(server=strng, local=string))): File path
            mappings between PMS server and local system.

        Fixup-specific parameters (kwargs in config):

          section_types (string or iterable(string)):
            The library section types that should be processed. Valid values
            are: 'movie', 'show'. For 'show', only its episodes will be
            processed (not the show item itself). A value of None (null in
            config file) means to process all valid section types. Optional,
            default is None.

          section_pattern (string):
            Regex pattern defining library section names that should be
            processed within the configured section types. A value of None
            (null in config file) means to process all library sections of the
            configured types. Optional, default is None.

          ffmpeg_fix_script (string):
            Path name of an ffmpeg fix script file generated by this fixup. The
            script file will contain ffmpeg commands that perform fixes on the
            metadata in the media files, for example to set the title tag from
            the title in the PMS item, if the title contains characters ffprobe
            cannot decode. A value of None (null in config file) disables the
            creation of the script file. Optional, default is None.
        """

        if section_types is None:
           section_types = ['movie', 'show']
        elif isinstance(section_types, six.string_types):
            section_types = [section_types]
        for st in section_types:
            if st not in ['movie', 'show']:
                print("Error: Invalid section type specified for fixup "
                      "{fixup}: {type}".
                      format(fixup=FIXUP_NAME, type=st))
                return 1

        if ffmpeg_fix_script:
            with open(ffmpeg_fix_script, 'w') as of:
                print("rem This script updates the title tag in media files. "
                      "Review it closely before running it!", file=of)
                print("rem This script uses Python encoding {!r}".
                      format(FIX_SCRIPT_ENCODING), file=of)

        for section in plex.library.sections():

            if section.type not in section_types:
                continue
            if section_pattern is not None and \
                    re.search(section_pattern, section.title) is None:
                if verbose:
                    print("Skipping {s.type} library section {s.title!r} "
                          "that does not match the specified pattern".
                          format(s=section))
                    sys.stdout.flush()
                continue

            print("Processing library section of type {s.type}: "
                  "{s.title!r}".
                  format(s=section))
            sys.stdout.flush()

            items = section.all()
            for item in items:
                if item.type == 'movie':
                    rc = process_item(
                        dryrun, verbose, ffmpeg_fix_script, item,
                        path_mappings)
                    if rc:
                        return rc
                elif item.type == 'show':
                    ep_items = item.episodes()
                    for ep_item in ep_items:
                        rc = process_item(
                            dryrun, verbose, ffmpeg_fix_script, ep_item,
                            path_mappings)
                        if rc:
                            return rc
                else:
                    print("Error: Invalid section type {type!r} encountered in "
                          "library section {s.title!r}".
                          format(type=item.type, s=section))
                    return 1

        return 0


def local_path(server_path, path_mappings):
    """
    Return the local path for a server_path, translating it using the
    specified path_mappings.
    """
    for mapping in path_mappings:
        server_root = mapping.get('server')
        local_root = mapping.get('local')
        if server_path.startswith(server_root):
            relpath = server_path[len(server_root)+1:]
            return os.path.join(local_root, relpath)
    return None


def get_title_tag(media_file):
    """
    Retrieve the title tag from the metadata of the specified media_file
    using the ffprobe command and return it as a unicode string.
    """

    media_file = ensure_unicode(media_file)

    # When invoking a system command, its command line arguments need to be
    # byte strings in file system encoding. If we pass command line
    # arguments as unicode strings, the subcommand package implementation
    # encodes them to byte strings using the 'ascii' encoder, which fails
    # if they contain non-ASCII characters.
    media_file_b = media_file.encode(sys.getfilesystemencoding())

    ffprobe = ffmpy.FFprobe(
        global_options=['-hide_banner', '-show_format', '-of', 'json'],
        inputs={media_file_b: None})

    try:
        stdout, stderr = ffprobe.run(
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
    except (UnicodeDecodeError, UnicodeEncodeError) as exc:
        print("Error: Unicode conversion issue when invoking {cmd!r}: "
              "{msg!r}".
              format(cmd=ffprobe.cmd, msg=exc))
        return 1
    except ffmpy.FFRuntimeError as exc:
        print("Error: ffprobe failed on file {file!r}: {msg!r}".
              format(file=media_file, msg=exc))
        return 1

    stdout_u = ensure_unicode(stdout)
    try:
        out = json.loads(stdout_u)
    except ValueError:
        print("Error: ffprobe returned invalid JSON for "
              "file {file!r}: {out!r}".
              format(file=media_file, out=stdout_u))
        return 1

    tags = out['format'].get('tags', dict())
    title_tag = tags.get('title', None)

    return title_tag


def process_item(dryrun, verbose, ffmpeg_fix_script, item, path_mappings):
    """
    Process one movie or episode item
    """

    title_info_list = []  # list items: tuple(local_file, title_tag)

    for part in item.iterParts():

        # Get title tag from metadata in file.

        # Note: part.file is a byte string if it only contains 7-bit ASCII
        # characers, or otherwise a unicode string.
        server_file = ensure_unicode(part.file)

        local_file = local_path(server_file, path_mappings)
        if local_file is None:
            print("Error: Cannot map server file {sf!r} using path "
                  "mappings {pm!r}".
                  format(sf=part.file, pm=path_mappings))
            return 1
        if not os.path.exists(local_file):
            print("Error: Cannot find local media file {lf!r} for {i.type} "
                  "{i.title!r}".
                  format(i=item, lf=local_file))
            return 1
        title_tag = get_title_tag(local_file)
        title_info_list.append((local_file, title_tag))

    title_tag = None
    for _local_file, _title_tag in title_info_list:
        if title_tag is None:
            title_tag = _title_tag
        elif title_tag != _title_tag:
            if verbose:
                print("Skipping {i.type} {i.title!r} with multiple media "
                      "files that have different title tags set "
                      "(file, title): {info}".
                      format(i=item, info=title_info_list))
                sys.stdout.flush()
            return 0

    # If the file has no title tag set, we cannot sync from it
    if not title_tag:
        if verbose:
            print("Skipping {i.type} {i.title!r} that has no title tag "
                  "set in media file {file!r}".
                  format(i=item, file=local_file))
            sys.stdout.flush()
        return 0

    # If the title tag contains the Unicode replacement character (U+FFFD),
    # this is caused by the use of encodings other than UTF-8 in the metadata
    # of the media file. ffprobe only supports a UTF-8 encoding and generates
    # the Unicode replacement character for any code points that are invalid
    # UTF-8. This happens for example with .avi files where the AVI tag editor
    # uses some encoding other than UTF-8.
    if u"\ufffd" in title_tag:
        if verbose:
            print("Skipping {i.type} {i.title!r} that has a media file "
                  "{file!r} whose title tag contains characters ffprobe could "
                  "not decode: {t!r}".
                  format(i=item, file=local_file, t=title_tag))
            sys.stdout.flush()
        ext = os.path.splitext(local_file)[1].lower()

        if ffmpeg_fix_script and ext != '.avi':

            # PMS does not appear to use the title tag of AVI files, so it
            # is not worthwhile fixing it. In addition, AVI editors do not
            # seem to use UTF-8 encoding in the metadata of AVI files (in fact,
            # most players e.g. VLC display UTF-8 titles in AVI files
            # incorrectly), so fixing it by using UTF-8 is not desirable.
            # For these reasons, we do not fix AVI files.

            print("Adding ffmpeg command to fix script {script!r} for "
                  "media file {file!r}".
                  format(file=local_file, script=ffmpeg_fix_script))
            sys.stdout.flush()
            lf_parts = os.path.splitext(local_file)
            outfile = lf_parts[0] + u'.fixed' + lf_parts[1]
            title = ensure_unicode(item.title)
            fix_cmd = u'ffmpeg -i "{infile}" -metadata title="{title}" ' \
                u'-codec copy "{outfile}"'. \
                format(infile=local_file, outfile=outfile, title=title)
            try:
                # Not all characters that are valid for file names can be
                # represented in the code page for the console. Example: U+2013
                fix_cmd_b = fix_cmd.encode(FIX_SCRIPT_ENCODING)
            except UnicodeEncodeError:
                fix_cmd = 'rem ' + fix_cmd
                fix_cmd_b = fix_cmd.encode('utf-8')
            with open(ffmpeg_fix_script, 'a') as of:
                print(fix_cmd_b, file=of)
        return 0

    # If the title field is already synced, nothing needs to be done
    if item.title == title_tag:
        return 0

    dryrun_str = "Dryrun: " if dryrun else ""

    if verbose:
        print("{d}Changing title field of {i.type} {i.title!r} "
              "to {title_tag!r}".
              format(d=dryrun_str, title_tag=title_tag, i=item))
        sys.stdout.flush()

    if not dryrun:

        # Change the title field
        new_title = title_tag
        new_title_b = ensure_bytes(new_title)
        parm_type = plexapi.utils.SEARCHTYPES[item.type]
        parms = {
            'type': parm_type,
            'id': item.ratingKey,
            'title.value': new_title_b,
            'title.locked': 1,
        }
        try:
            item.edit(**parms)
        except plexapi.exceptions.PlexApiException as exc:
            print("Error: Cannot set the title field of {i.type} {i.title!r} "
                  "to {new_title!r}: {msg}".
                  format(i=item, new_title=new_title, msg=exc))
            return 1

        # Verify the title field was changed
        item.reload()
        if item.title != new_title:
            print("Error: Attempt to set the title field of {i.type} "
                  "{i.title!r} to {new_title!r} did not stick".
                  format(i=item, new_title=new_title))
            return 1

    return 0
